# Yandex Cup 2021 Квалификация

## A. Выбраться из лабиринта (20 баллов)

Вы начинаете свой путь в темном лабиринте мрачного подземелья. В углу видите маленькую оплывшую свечку. Осторожно, чтобы не задуть, берете ее в руки и оглядываетесь по сторонам. На полу замечаете несколько разбитых склянок и одну целую. Поднимаете и внимательно осматриваете бутылочку. Да в ней записка! Разворачиваете пожелтевший от времени листок: «Смекалка, упорство и находчивость приведут тебя к Алхимику». Неужели Алхимик правда существует и можно попытаться его найти? — размышляете вы. Но сначала нужно выбраться отсюда. Итак, ваша первая задача — проложить себе путь из лабиринта. Наверняка, что-то подобное вы уже решали на работе, осталось только вспомнить алгоритм!

В задаче требуется написать функцию для выхода из лабиринта (гарантируется, что выход есть всегда).

Далее описание функции и параметров дано на Typescript, но функцию требуется написать на JS.

```ts
// Функция должна вернуть точку x, y, для которой game.state(x, y).finish === true
// start - некая начальная точка.
// Не деструктурируйте game, ваше решение не будет проходить тесты.
module.exports = function main(game: Game, start: Point): Promise<Point> {

}
```

У game есть асинхронные функции, которые позволяют двигаться от любой ячейки влево/вправо/вверх/вниз (при попытке шагнуть в стену или шагнуть из не посещенной клетки кидает ошибку). А также асинхронная функция получения состояния ячейки (работает только для посещенных ячеек, для остальных кидает ошибку).

Ось x в лабиринте идет слева-направа, y - сверху-вниз.

### Формат данных

```ts
export interface Point {
    x: number;
    y: number;
}

export interface Game {
    // Попытаться шагнуть из клетки лабиринта вверх
    up(x: number, y: number): Promise<void>;
    // Попытаться шагнуть из клетки лабиринта вниз
    down(x: number, y: number): Promise<void>;
    // Попытаться шагнуть из клетки лабиринта влево
    left(x: number, y: number): Promise<void>;
    // Попытаться шагнуть из клетки лабиринта вправо
    right(x: number, y: number): Promise<void>;

    // Получить состояние клетки лабиринта
    state(x: number, y: number): Promise<{
        top: boolean; // можно ли шагать вверх
        bottom: boolean; // можно ли шагать вниз
        left: boolean; // можно ли шагать влево
        right: boolean; // можно ли шагать вправо
        start: boolean; // ячейка - стартовая
        finish: boolean; // ячейка - финиш
    }>;
}
```

Для тестирования решения скачивайте приложенный файл labyrinth-tester.zip (ссылка "Скачать условие задачи" ниже), в нем в файле src/main.js можно писать решение и визуализировать прохождение лабиринта.

Есть следующие ограничения:

- Ограничение времени: 10 секунд
- Ограничение памяти: 64.0 Мб

Решение будет проверяться на Node 12.

## B. Разместить объявление (20 баллов)

Вы успешно выбрались из лабиринта и оказались в деревне. Так как же найти Алхимика? Идете дальше, чтобы осмотреться, и замечаете метровую доску со столбцами. А на ней всего три объявления, нелепо растянутые слева направо по всей поверхности: «Волшебник ищет помощника», «Информация по золотым монетам» и «Съедобные лягушки оптом».

А что если тоже разместить объявление, которое поможет найти Алхимика? Вы уже занесли руку, чтобы прикрепить свой листок, но внезапно к вам подходит местный житель. Он раздраженно отталкивает вас: «Стой, ты что, не видишь? Для твоего объявления места нет».

Вы пытаетесь доказать жителю, что он заблуждается: «Вы не правы. Можно легко оптимизировать и разместить все объявления. А вообще, попробуйте доски Kanban, мы на работе только ими и пользуемся». «Повесить объявление на кабана? Ты издеваешься? А ну пойдем к Старейшине!» — ворчит мужичок и тащит вас к главе деревни. В древнем святилище вас встречает Старейшина. «Покажи нам, как исправить эту ситуацию», — разрешает седовласый старец.

Итак, ваша новая задача — разработать инструкцию, как правильно вместить все объявления в столбцы.

### Формат ввода

В функцию `renderWaterfall`, которую нужно написать, передаётся три параметра:

- `rootNode`: элемент в котором находятся объявления (HTMLDivElement)
- `columnCount`: количество колонок (number)
- `elementGap`: расстояние между колонками, а также элементами по-вертикали (number)

Пример rootNode:

```html
<div class="root">
  <div class="el">У каждого объявления есть свои стили</div>
  <div class="el">Их не нужно менять</div>
  <div class="el">Каждое объявление должно быть свободным по высоте</div>
  <div class="el">А вот ширину нужно будет выставить</div>
  <div class="el">Ширину элемента root, при необходимости вы можете определить, но в тестах она может быть разная</div>
</div>
```

### Формат вывода

Напишите свою js функцию с именем renderWaterfall. Она будет вставлена на html страницу и вызвана с нужными параметрами. Влияйте на DOM так, чтобы объявления расположились в указанное количество колонок, между ними было расстояние elementGap. Правило расположение элемента в колонку следующее: нужно помещать элемент в ту колонку, высота которой меньше всего. При равных наименьших высотах выбирается самая левая колонка среди них.

Например:

```js
function renderWaterfall(rootNode, columnCount, elementGap) {
...
}
```

### Примечания

Не удаляйте существующие классы элементов. Вы можете изменять ширину объявлений, но высота должна быть зависимой от контента. Можно добавлять свои дополнительные элементы для структурирования.

Посмотрите пример ожидаемого расположения элементов. ![](./d-example.png)
